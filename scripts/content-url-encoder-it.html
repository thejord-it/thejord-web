<h2>Cos'√® la Codifica URL e Perch√© √à Necessaria</h2>

<p>La <strong>codifica URL</strong> (URL encoding o percent-encoding) √® un meccanismo fondamentale del web che permette di trasmettere caratteri speciali all'interno degli indirizzi web. Quando inserisci una query di ricerca su Google, invii dati tramite form o costruisci API REST, i caratteri speciali vengono automaticamente convertiti in sequenze sicure che possono viaggiare attraverso internet senza causare problemi di parsing o interpretazione errata.</p>

<p>Il nostro <strong>URL Encoder/Decoder</strong> √® uno strumento completamente gratuito che funziona al 100% nel tuo browser, senza inviare alcun dato a server esterni. √à perfetto per sviluppatori, SEO specialist, system administrator e chiunque lavori quotidianamente con URL, parametri web e API RESTful.</p>

<h2>Come Funziona il Percent-Encoding (RFC 3986)</h2>

<p>Gli URL (<strong>Uniform Resource Locator</strong>) possono contenere solo un set limitato di caratteri ASCII. Secondo la specifica <a href="https://datatracker.ietf.org/doc/html/rfc3986" target="_blank" rel="noopener">RFC 3986</a>, i caratteri permessi negli URL sono suddivisi in:</p>

<ul>
  <li><strong>Caratteri non riservati</strong>: A-Z, a-z, 0-9, - _ . ~ (sempre sicuri)</li>
  <li><strong>Caratteri riservati</strong>: : / ? # [ ] @ ! $ &amp; ' ( ) * + , ; = (hanno significato speciale)</li>
</ul>

<p>Tutti gli altri caratteri (spazi, lettere accentate, emoji, simboli) devono essere <strong>codificati</strong> per essere trasmessi correttamente attraverso il protocollo HTTP.</p>

<h3>Il Processo di Conversione</h3>

<p>Il percent-encoding converte ogni carattere non sicuro nel suo valore esadecimale UTF-8, preceduto dal simbolo <code>%</code>:</p>

<pre><code>Carattere ‚Üí Byte UTF-8 ‚Üí Percent-Encoded

Spazio    ‚Üí 0x20      ‚Üí %20
√®         ‚Üí 0xC3 0xA8 ‚Üí %C3%A8
√†         ‚Üí 0xC3 0xA0 ‚Üí %C3%A0
‚Ç¨         ‚Üí 0xE2 0x82 0xAC ‚Üí %E2%82%AC
üòÄ        ‚Üí 0xF0 0x9F 0x98 0x80 ‚Üí %F0%9F%98%80</code></pre>

<h2>Tabella dei Caratteri Pi√π Comuni</h2>

<table>
<thead>
<tr>
<th>Carattere</th>
<th>Codifica URL</th>
<th>Descrizione</th>
<th>Uso Tipico</th>
</tr>
</thead>
<tbody>
<tr><td>Spazio</td><td><code>%20</code> o <code>+</code></td><td>Spazio bianco</td><td>Query string</td></tr>
<tr><td>!</td><td><code>%21</code></td><td>Punto esclamativo</td><td>Testi, messaggi</td></tr>
<tr><td>#</td><td><code>%23</code></td><td>Hash/Cancelletto</td><td>Fragment identifier</td></tr>
<tr><td>$</td><td><code>%24</code></td><td>Dollaro</td><td>Prezzi, valute</td></tr>
<tr><td>%</td><td><code>%25</code></td><td>Percentuale</td><td>Percentuali, escape</td></tr>
<tr><td>&amp;</td><td><code>%26</code></td><td>Ampersand</td><td>Separatore parametri</td></tr>
<tr><td>'</td><td><code>%27</code></td><td>Apostrofo</td><td>Testi italiani</td></tr>
<tr><td>+</td><td><code>%2B</code></td><td>Pi√π</td><td>Operazioni matematiche</td></tr>
<tr><td>,</td><td><code>%2C</code></td><td>Virgola</td><td>Liste, separatori</td></tr>
<tr><td>/</td><td><code>%2F</code></td><td>Slash</td><td>Path URL</td></tr>
<tr><td>:</td><td><code>%3A</code></td><td>Due punti</td><td>Porte, protocolli</td></tr>
<tr><td>=</td><td><code>%3D</code></td><td>Uguale</td><td>Assegnazione parametri</td></tr>
<tr><td>?</td><td><code>%3F</code></td><td>Punto interrogativo</td><td>Inizio query string</td></tr>
<tr><td>@</td><td><code>%40</code></td><td>Chiocciola</td><td>Email, credenziali</td></tr>
<tr><td>√®</td><td><code>%C3%A8</code></td><td>e accentata</td><td>Italiano</td></tr>
<tr><td>√±</td><td><code>%C3%B1</code></td><td>e√±e</td><td>Spagnolo</td></tr>
</tbody>
</table>

<h2>7+ Casi d'Uso Reali con Esempi</h2>

<h3>1. Query String nei Motori di Ricerca</h3>

<p>Quando cerchi "caff√® italiano migliore" su Google, l'URL diventa:</p>

<pre><code>https://www.google.com/search?q=caff%C3%A8%20italiano%20migliore</code></pre>

<p>Senza codifica, il server non saprebbe interpretare correttamente la lettera accentata "√®".</p>

<h3>2. Parametri API REST</h3>

<p>Le API moderne spesso richiedono parametri codificati per filtri complessi:</p>

<pre><code>GET /api/users?filter=nome%3DMario%26citt%C3%A0%3DRoma%26et%C3%A0%3E30

// Decodificato: filter=nome=Mario&amp;citt√†=Roma&amp;et√†>30</code></pre>

<h3>3. Link di Condivisione Social</h3>

<p>I link di condivisione includono URL e testo codificati:</p>

<pre><code>https://twitter.com/intent/tweet?url=https%3A%2F%2Fthejord.it%2Ftools&amp;text=Ottimi%20tool%20per%20sviluppatori%21

// Decodificato: url=https://thejord.it/tools&amp;text=Ottimi tool per sviluppatori!</code></pre>

<h3>4. OAuth Redirect URI</h3>

<p>I sistemi di autenticazione OAuth 2.0 usano redirect_uri codificati:</p>

<pre><code>https://accounts.google.com/oauth2/auth
  ?client_id=xyz
  &amp;redirect_uri=https%3A%2F%2Fmyapp.com%2Fauth%2Fcallback
  &amp;scope=email%20profile
  &amp;response_type=code</code></pre>

<h3>5. Form Data (application/x-www-form-urlencoded)</h3>

<p>I form HTML inviano dati con codifica URL per default:</p>

<pre><code>POST /contact HTTP/1.1
Content-Type: application/x-www-form-urlencoded

nome=Mario+Rossi&amp;email=mario%40example.com&amp;messaggio=Ciao%2C+vorrei+informazioni%21</code></pre>

<h3>6. Cookie Values</h3>

<p>I valori dei cookie contenenti JSON devono essere codificati:</p>

<pre><code>Set-Cookie: user_prefs=%7B%22theme%22%3A%22dark%22%2C%22lang%22%3A%22it%22%7D

// Decodificato: {"theme":"dark","lang":"it"}</code></pre>

<h3>7. Deep Links per App Mobile</h3>

<p>I deep link per iOS/Android usano URL encoding per parametri:</p>

<pre><code>myapp://product/view?name=Caff%C3%A8%20Espresso&amp;price=2.50&amp;category=bevande%20calde</code></pre>

<h3>8. Webhook Payload URLs</h3>

<p>I webhook (Slack, Discord, etc.) richiedono URL codificati nei payload:</p>

<pre><code>https://hooks.slack.com/services/xxx/yyy?text=Deploy%20completato%20%E2%9C%85%20su%20produzione</code></pre>

<h2>Esempi di Codice in 5+ Linguaggi</h2>

<h3>JavaScript (Browser e Node.js)</h3>

<pre><code class="language-javascript">// encodeURIComponent - per valori di parametri (RACCOMANDATO)
const encoded = encodeURIComponent('caff√® italiano ‚Ç¨5');
console.log(encoded); // caff%C3%A8%20italiano%20%E2%82%AC5

// decodeURIComponent - per decodificare
const decoded = decodeURIComponent(encoded);
console.log(decoded); // caff√® italiano ‚Ç¨5

// encodeURI - per URL completi (NON codifica : / ? # etc)
const url = encodeURI('https://example.com/path?q=caff√® espresso');
console.log(url); // https://example.com/path?q=caff%C3%A8%20espresso

// URLSearchParams - per costruire query string (MODERNO)
const params = new URLSearchParams({
  nome: 'Mario Rossi',
  citt√†: 'Roma',
  email: 'mario@example.com'
});
console.log(params.toString());
// nome=Mario+Rossi&amp;citt%C3%A0=Roma&amp;email=mario%40example.com

// URL API - per manipolare URL completi
const myUrl = new URL('https://api.example.com/search');
myUrl.searchParams.set('query', 'caff√® italiano');
myUrl.searchParams.set('limit', '10');
console.log(myUrl.href);
// https://api.example.com/search?query=caff%C3%A8+italiano&amp;limit=10</code></pre>

<h3>Python</h3>

<pre><code class="language-python">from urllib.parse import quote, unquote, urlencode, parse_qs

# quote - codifica singola stringa
encoded = quote('caff√® italiano ‚Ç¨5')
print(encoded)  # caff%C3%A8%20italiano%20%E2%82%AC5

# quote con safe chars personalizzati
encoded_safe = quote('path/to/file', safe='/')
print(encoded_safe)  # path/to/file (slash non codificato)

# unquote - decodifica
decoded = unquote(encoded)
print(decoded)  # caff√® italiano ‚Ç¨5

# urlencode - per dizionari (query string)
params = urlencode({
    'nome': 'Mario Rossi',
    'citt√†': 'Roma',
    'prezzo': '‚Ç¨5.00'
})
print(params)  # nome=Mario+Rossi&amp;citt%C3%A0=Roma&amp;prezzo=%E2%82%AC5.00

# parse_qs - parsing query string
parsed = parse_qs('nome=Mario&amp;citt√†=Roma')
print(parsed)  # {'nome': ['Mario'], 'citt√†': ['Roma']}</code></pre>

<h3>PHP</h3>

<pre><code class="language-php">&lt;?php
// urlencode - codifica (spazi come +)
$encoded = urlencode('caff√® italiano ‚Ç¨5');
echo $encoded; // caff%C3%A8+italiano+%E2%82%AC5

// rawurlencode - codifica RFC 3986 (spazi come %20)
$encoded_raw = rawurlencode('caff√® italiano');
echo $encoded_raw; // caff%C3%A8%20italiano

// urldecode / rawurldecode - decodifica
$decoded = urldecode($encoded);
echo $decoded; // caff√® italiano ‚Ç¨5

// http_build_query - per array associativi
$params = http_build_query([
    'nome' =&gt; 'Mario Rossi',
    'citt√†' =&gt; 'Roma',
    'tags' =&gt; ['php', 'web', 'api']
]);
echo $params;
// nome=Mario+Rossi&amp;citt%C3%A0=Roma&amp;tags%5B0%5D=php&amp;tags%5B1%5D=web&amp;tags%5B2%5D=api

// parse_str - parsing query string
parse_str('nome=Mario&amp;citt√†=Roma', $result);
print_r($result); // Array ( [nome] =&gt; Mario [citt√†] =&gt; Roma )
?&gt;</code></pre>

<h3>Java</h3>

<pre><code class="language-java">import java.net.URLEncoder;
import java.net.URLDecoder;
import java.nio.charset.StandardCharsets;

// Codifica
String encoded = URLEncoder.encode("caff√® italiano ‚Ç¨5", StandardCharsets.UTF_8);
System.out.println(encoded); // caff%C3%A8+italiano+%E2%82%AC5

// Decodifica
String decoded = URLDecoder.decode(encoded, StandardCharsets.UTF_8);
System.out.println(decoded); // caff√® italiano ‚Ç¨5

// Con Java 11+ HttpClient
import java.net.URI;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;

String query = URLEncoder.encode("caff√®", StandardCharsets.UTF_8);
URI uri = URI.create("https://api.example.com/search?q=" + query);
HttpRequest request = HttpRequest.newBuilder(uri).GET().build();</code></pre>

<h3>C# / .NET</h3>

<pre><code class="language-csharp">using System;
using System.Web;
using System.Net;

// HttpUtility.UrlEncode (System.Web)
string encoded = HttpUtility.UrlEncode("caff√® italiano ‚Ç¨5");
Console.WriteLine(encoded); // caff%c3%a8+italiano+%e2%82%ac5

// Uri.EscapeDataString (RFC 3986 compliant)
string encoded2 = Uri.EscapeDataString("caff√® italiano");
Console.WriteLine(encoded2); // caff%C3%A8%20italiano

// WebUtility.UrlEncode (.NET Core)
string encoded3 = WebUtility.UrlEncode("caff√® italiano");
Console.WriteLine(encoded3); // caff%C3%A8+italiano

// Decodifica
string decoded = HttpUtility.UrlDecode(encoded);
Console.WriteLine(decoded); // caff√® italiano ‚Ç¨5

// QueryString builder
var query = HttpUtility.ParseQueryString(string.Empty);
query["nome"] = "Mario Rossi";
query["citt√†"] = "Roma";
Console.WriteLine(query.ToString()); // nome=Mario+Rossi&amp;citt%c3%a0=Roma</code></pre>

<h3>Go</h3>

<pre><code class="language-go">package main

import (
    "fmt"
    "net/url"
)

func main() {
    // QueryEscape - codifica
    encoded := url.QueryEscape("caff√® italiano ‚Ç¨5")
    fmt.Println(encoded) // caff%C3%A8+italiano+%E2%82%AC5

    // QueryUnescape - decodifica
    decoded, _ := url.QueryUnescape(encoded)
    fmt.Println(decoded) // caff√® italiano ‚Ç¨5

    // url.Values - costruire query string
    params := url.Values{}
    params.Add("nome", "Mario Rossi")
    params.Add("citt√†", "Roma")
    fmt.Println(params.Encode()) // citt%C3%A0=Roma&amp;nome=Mario+Rossi
}</code></pre>

<h2>Confronto: URL Encoding vs Altre Codifiche</h2>

<table>
<thead>
<tr>
<th>Caratteristica</th>
<th>URL Encoding</th>
<th>Base64</th>
<th>HTML Entities</th>
<th>JSON Escape</th>
</tr>
</thead>
<tbody>
<tr><td><strong>Scopo principale</strong></td><td>URL sicuri</td><td>Dati binari ‚Üí testo</td><td>Caratteri HTML</td><td>Stringhe JSON</td></tr>
<tr><td><strong>Formato output</strong></td><td>%XX</td><td>A-Za-z0-9+/=</td><td>&amp;nome; o &amp;#123;</td><td>\uXXXX</td></tr>
<tr><td><strong>Overhead medio</strong></td><td>~3x per speciali</td><td>~1.33x sempre</td><td>~6x per speciali</td><td>~6x per speciali</td></tr>
<tr><td><strong>Preserva leggibilit√†</strong></td><td>Parziale</td><td>No</td><td>S√¨</td><td>Parziale</td></tr>
<tr><td><strong>Standard</strong></td><td>RFC 3986</td><td>RFC 4648</td><td>HTML5</td><td>RFC 8259</td></tr>
<tr><td><strong>Uso con binari</strong></td><td>No</td><td>S√¨</td><td>No</td><td>No</td></tr>
<tr><td><strong>Caso d'uso tipico</strong></td><td>Query string</td><td>Immagini inline</td><td>Pagine web</td><td>API response</td></tr>
</tbody>
</table>

<h2>FAQ - Domande Frequenti</h2>

<h3>Qual √® la differenza tra encodeURI e encodeURIComponent in JavaScript?</h3>

<p><code>encodeURI()</code> codifica un URL completo, lasciando intatti i caratteri strutturali come <code>:</code>, <code>/</code>, <code>?</code>, <code>#</code>, <code>&amp;</code>. √à utile quando hai un URL completo con caratteri speciali solo nel path o query. <code>encodeURIComponent()</code> codifica <strong>tutto</strong> tranne lettere, numeri e <code>- _ . ~</code>. Usa <code>encodeURIComponent()</code> per i <strong>valori</strong> dei parametri, <code>encodeURI()</code> per URL completi gi√† formati.</p>

<h3>Perch√© lo spazio diventa %20 oppure + ?</h3>

<p>Secondo RFC 3986 (URI Generic Syntax), lo spazio deve diventare <code>%20</code>. Tuttavia, nel formato <code>application/x-www-form-urlencoded</code> (usato dai form HTML e definito in HTML5), lo spazio diventa <code>+</code> per compatibilit√† storica. Entrambi sono validi ma in contesti diversi. Per sicurezza, usa sempre <code>%20</code> negli URL e accetta entrambi in decodifica.</p>

<h3>Come gestisco i caratteri Unicode (emoji, cinese, arabo)?</h3>

<p>I caratteri Unicode vengono prima convertiti nella loro rappresentazione UTF-8 (1-4 byte), poi ogni byte viene percent-encoded. Un emoji come üòÄ (U+1F600) diventa <code>%F0%9F%98%80</code> perch√© in UTF-8 occupa 4 byte. Un carattere cinese come ‰∏≠ (U+4E2D) diventa <code>%E4%B8%AD</code> (3 byte UTF-8).</p>

<h3>La codifica URL fornisce sicurezza?</h3>

<p><strong>Assolutamente no</strong>. La codifica URL √® completamente reversibile e serve esclusivamente a trasmettere caratteri speciali senza corrompere la struttura dell'URL. Non fornisce alcuna protezione dei dati. Per proteggere informazioni sensibili usa sempre HTTPS, crittografia end-to-end e mai includere password o token sensibili negli URL.</p>

<h3>Devo codificare l'intero URL o solo i parametri?</h3>

<p>Codifica solo i <strong>valori</strong> dei parametri, mai l'intera struttura dell'URL. La struttura (<code>https://</code>, <code>/path/</code>, <code>?</code>, <code>&amp;</code>, <code>=</code>) deve rimanere intatta per funzionare. Esempio corretto: <code>?name=</code> + <code>encodeURIComponent(value)</code>.</p>

<h3>Come evito la doppia codifica (double encoding)?</h3>

<p>La doppia codifica avviene quando codifichi testo gi√† codificato: <code>%20</code> diventa <code>%2520</code>. Per evitarla: 1) Decodifica sempre prima di ri-codificare, 2) Verifica se il testo contiene pattern <code>%XX</code> prima di codificare, 3) Usa funzioni che gestiscono questo caso automaticamente. La doppia codifica pu√≤ anche indicare un tentativo di attacco.</p>

<h3>Qual √® la lunghezza massima di un URL?</h3>

<p>Non esiste un limite ufficiale nelle specifiche, ma nella pratica: Internet Explorer supporta fino a 2083 caratteri, Chrome/Firefox/Safari circa 65.000 caratteri, ma molti server hanno limiti inferiori (8KB tipico per Apache/Nginx). Per dati grandi, usa POST invece di GET.</p>

<h3>Come testo se il mio URL √® codificato correttamente?</h3>

<p>Usa il nostro <a href="/tools/url-encoder">URL Encoder/Decoder</a> per verificare. Incolla l'URL, decodificalo e controlla se il risultato √® il testo originale. Un URL ben formato deve: 1) Non contenere spazi (solo %20 o +), 2) Non contenere caratteri non-ASCII visibili, 3) Decodificarsi senza errori.</p>

<h2>Best Practice per la Sicurezza</h2>

<h3>‚úÖ Cosa Fare</h3>

<ul>
  <li><strong>Codifica sempre l'input utente</strong> prima di inserirlo in URL per prevenire injection</li>
  <li><strong>Usa le librerie standard</strong> del tuo linguaggio - evita implementazioni custom</li>
  <li><strong>Valida gli URL dopo la decodifica</strong> per prevenire attacchi path traversal</li>
  <li><strong>Usa HTTPS</strong> per proteggere i dati in transito (gli URL sono visibili nei log)</li>
  <li><strong>Limita la lunghezza</strong> degli URL accettati per prevenire DoS</li>
  <li><strong>Sanitizza i path</strong> decodificati prima di accedere al filesystem</li>
</ul>

<h3>‚ùå Cosa NON Fare</h3>

<ul>
  <li><strong>Non fidarti mai di URL decodificati</strong> senza validazione - possono contenere payload malevoli</li>
  <li><strong>Non costruire URL concatenando stringhe</strong> senza codificare i valori</li>
  <li><strong>Non assumere che la codifica prevenga XSS o SQL injection</strong> - serve solo per il trasporto</li>
  <li><strong>Non inserire mai password, token o dati sensibili negli URL</strong> - sono loggati ovunque</li>
  <li><strong>Non ignorare la doppia codifica</strong> - pu√≤ indicare un tentativo di bypass</li>
</ul>

<h3>Esempio di Codice Sicuro</h3>

<pre><code class="language-javascript">// ‚ùå PERICOLOSO - URL injection possibile
const url = `https://api.com/user?id=${userId}&amp;name=${userName}`;

// ‚úÖ SICURO - sempre codificare i valori utente
const url = `https://api.com/user?id=${encodeURIComponent(userId)}&amp;name=${encodeURIComponent(userName)}`;

// ‚úÖ ANCORA MEGLIO - validare prima, poi codificare
function buildUserUrl(userId, userName) {
  // Validazione
  if (!/^[a-zA-Z0-9_-]+$/.test(userId)) {
    throw new Error('Invalid userId');
  }
  if (userName.length > 100) {
    throw new Error('userName too long');
  }

  // Costruzione sicura
  const params = new URLSearchParams({ id: userId, name: userName });
  return `https://api.com/user?${params}`;
}</code></pre>

<h2>Tool Correlati su THEJORD</h2>

<p>Scopri altri strumenti utili per sviluppatori e professionisti del web:</p>

<ul>
  <li><a href="/tools/base64">Base64 Encoder/Decoder</a> - Codifica e decodifica dati binari in formato ASCII sicuro</li>
  <li><a href="/tools/json-formatter">JSON Formatter</a> - Formatta, valida e minimizza dati JSON con syntax highlighting</li>
  <li><a href="/tools/hash-generator">Hash Generator</a> - Genera hash MD5, SHA-1, SHA-256, SHA-512 per verifica integrit√†</li>
  <li><a href="/tools/regex-tester">RegEx Tester</a> - Testa e debugga espressioni regolari in tempo reale</li>
  <li><a href="/tools/diff-checker">Diff Checker</a> - Confronta due testi e trova le differenze</li>
</ul>

<h2>Risorse Esterne Autorevoli</h2>

<ul>
  <li><a href="https://datatracker.ietf.org/doc/html/rfc3986" target="_blank" rel="noopener">RFC 3986 - URI Generic Syntax</a> - Specifica ufficiale IETF</li>
  <li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/encodeURIComponent" target="_blank" rel="noopener">MDN - encodeURIComponent()</a> - Documentazione JavaScript</li>
  <li><a href="https://en.wikipedia.org/wiki/Percent-encoding" target="_blank" rel="noopener">Wikipedia - Percent-encoding</a> - Panoramica generale</li>
</ul>

<p><strong><a href="/tools/url-encoder">üîó Prova il nostro URL Encoder/Decoder gratuito ‚Üí</a></strong></p>
