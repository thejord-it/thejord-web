<h1>Internationalizing THEJORD: How We Implemented i18n with Next.js</h1>

<p>THEJORD.IT is available in <strong>Italian</strong> and <strong>English</strong> from launch, with plans to expand to other European languages soon. In this technical article, we explore how we implemented internationalization (i18n) with Next.js 16, the challenges faced, and the best practices adopted.</p>

<h2>Why Multilingual Matters</h2>

<p>Internationalization isn't just translating text. It's making the product accessible, culturally appropriate, and SEO-friendly for different markets:</p>

<ul>
<li><strong>Accessibility</strong>: 90% of users prefer content in their native language</li>
<li><strong>SEO</strong>: Better Google ranking for local queries (e.g., "confronta testi" vs "compare text")</li>
<li><strong>User Experience</strong>: Local formats (dates, numbers, currencies) improve UX</li>
<li><strong>Market Expansion</strong>: Open to non-English markets (Europe, LATAM, Asia)</li>
<li><strong>Legal Compliance</strong>: Some regions require content in local language</li>
</ul>

<h3>i18n Goals for THEJORD</h3>

<ul>
<li>âœ… Italian and English support at launch</li>
<li>âœ… Instant language switching without reload</li>
<li>âœ… SEO-friendly localized URLs (thejord.it/it/tools vs /en/tools)</li>
<li>âœ… Language-specific content (translated blog posts)</li>
<li>âœ… Local formats (dates, numbers)</li>
<li>ğŸ”œ Expansion to French, Spanish, German (Q2 2025)</li>
</ul>

<h2>THEJORD i18n Architecture</h2>

<h3>Next.js App Router with [locale] Segment</h3>

<p>THEJORD uses the `[locale]` pattern for multilingual routing:</p>

<pre><code>app/
â”œâ”€â”€ [locale]/                  # Dynamic locale segment
â”‚   â”œâ”€â”€ layout.tsx             # Root layout (locale provider)
â”‚   â”œâ”€â”€ page.tsx               # Homepage (/) â†’ redirect to /it or /en
â”‚   â”œâ”€â”€ tools/
â”‚   â”‚   â”œâ”€â”€ diff-checker/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx       # /it/tools/diff-checker or /en/tools/diff-checker
â”‚   â”‚   â””â”€â”€ ...
â”‚   â”œâ”€â”€ blog/
â”‚   â”‚   â”œâ”€â”€ [slug]/
â”‚   â”‚   â”‚   â””â”€â”€ page.tsx       # /en/blog/diff-checker-compare-texts
â”‚   â”‚   â””â”€â”€ page.tsx
â”‚   â””â”€â”€ not-found.tsx          # Localized 404
â”œâ”€â”€ middleware.ts              # Locale detection & redirect
â””â”€â”€ i18n/
    â”œâ”€â”€ locales/
    â”‚   â”œâ”€â”€ it.json            # Italian translations
    â”‚   â””â”€â”€ en.json            # English translations
    â”œâ”€â”€ config.ts              # i18n configuration
    â””â”€â”€ server.ts              # Server-side i18n utilities</code></pre>

<h3>Middleware for Locale Detection</h3>

<pre><code>// middleware.ts
import { NextResponse } from 'next/server'
import type { NextRequest } from 'next/server'
import { match as matchLocale } from '@formatjs/intl-localematcher'
import Negotiator from 'negotiator'

const locales = ['it', 'en']
const defaultLocale = 'en'

function getLocale(request: NextRequest): string {
  // 1. Check URL path (highest priority)
  const pathname = request.nextUrl.pathname
  const pathnameLocale = locales.find(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )
  if (pathnameLocale) return pathnameLocale

  // 2. Check cookie
  const localeCookie = request.cookies.get('NEXT_LOCALE')?.value
  if (localeCookie && locales.includes(localeCookie)) {
    return localeCookie
  }

  // 3. Check Accept-Language header
  const headers = { 'accept-language': request.headers.get('accept-language') || '' }
  const languages = new Negotiator({ headers }).languages()

  try {
    return matchLocale(languages, locales, defaultLocale)
  } catch {
    return defaultLocale
  }
}

export function middleware(request: NextRequest) {
  const pathname = request.nextUrl.pathname

  // Skip middleware for static files
  if (
    pathname.startsWith('/_next') ||
    pathname.includes('/api/') ||
    pathname.match(/\.(ico|png|jpg|jpeg|svg|css|js)$/)
  ) {
    return NextResponse.next()
  }

  // Check if locale is in pathname
  const pathnameHasLocale = locales.some(
    (locale) => pathname.startsWith(`/${locale}/`) || pathname === `/${locale}`
  )

  if (pathnameHasLocale) {
    return NextResponse.next()
  }

  // Redirect to localized URL
  const locale = getLocale(request)
  request.nextUrl.pathname = `/${locale}${pathname}`

  const response = NextResponse.redirect(request.nextUrl)
  response.cookies.set('NEXT_LOCALE', locale, { maxAge: 31536000 }) // 1 year

  return response
}

export const config = {
  matcher: [
    // Match all paths except static files and API
    '/((?!_next|api|favicon.ico).*)',
  ],
}</code></pre>

<h3>Translation Files (JSON)</h3>

<pre><code>// i18n/locales/en.json
{
  "common": {
    "tools": "Tools",
    "blog": "Blog",
    "darkMode": "Dark Mode",
    "language": "Language"
  },
  "tools": {
    "diffChecker": {
      "title": "Diff Checker",
      "description": "Compare text and code",
      "placeholder1": "Paste first text here...",
      "placeholder2": "Paste second text here...",
      "compare": "Compare",
      "clear": "Clear",
      "copy": "Copy Result"
    },
    "hashGenerator": {
      "title": "Hash Generator",
      "description": "Generate MD5, SHA-256, SHA-512 hashes",
      "selectAlgorithm": "Select Algorithm",
      "generate": "Generate Hash"
    }
  },
  "blog": {
    "readMore": "Read more",
    "publishedOn": "Published on {{date}}",
    "readTime": "{{time}} min read",
    "relatedPosts": "Related Posts"
  }
}</code></pre>

<h2>Client-Side Implementation</h2>

<h3>Context Provider for i18n</h3>

<pre><code>// app/[locale]/layout.tsx
import { IntlProvider } from '@/components/IntlProvider'
import { getMessages } from '@/i18n/server'

export default async function LocaleLayout({
  children,
  params,
}: {
  children: React.ReactNode
  params: { locale: string }
}) {
  const messages = await getMessages(params.locale)

  return (
    <html lang={params.locale}>
      <body>
        <IntlProvider locale={params.locale} messages={messages}>
          {children}
        </IntlProvider>
      </body>
    </html>
  )
}</code></pre>

<pre><code>// components/IntlProvider.tsx
'use client'

import { createContext, useContext } from 'react'

interface IntlContextValue {
  locale: string
  messages: Record<string, any>
  t: (key: string, params?: Record<string, any>) => string
}

const IntlContext = createContext<IntlContextValue | null>(null)

export function IntlProvider({
  locale,
  messages,
  children,
}: {
  locale: string
  messages: Record<string, any>
  children: React.ReactNode
}) {
  const t = (key: string, params?: Record<string, any>) => {
    const keys = key.split('.')
    let value: any = messages

    for (const k of keys) {
      value = value?.[k]
    }

    if (typeof value !== 'string') {
      console.warn(`Translation missing: ${key}`)
      return key
    }

    // Simple parameter replacement
    if (params) {
      return value.replace(/\{\{(\w+)\}\}/g, (_, param) => params[param] || '')
    }

    return value
  }

  return (
    <IntlContext.Provider value={{ locale, messages, t }}>
      {children}
    </IntlContext.Provider>
  )
}

export function useIntl() {
  const context = useContext(IntlContext)
  if (!context) {
    throw new Error('useIntl must be used within IntlProvider')
  }
  return context
}</code></pre>

<h3>Usage in Components</h3>

<pre><code>// components/DiffChecker.tsx
'use client'

import { useIntl } from '@/components/IntlProvider'

export function DiffChecker() {
  const { t } = useIntl()

  return (
    <div>
      <h1>{t('tools.diffChecker.title')}</h1>
      <p>{t('tools.diffChecker.description')}</p>

      <textarea placeholder={t('tools.diffChecker.placeholder1')} />
      <textarea placeholder={t('tools.diffChecker.placeholder2')} />

      <button>{t('tools.diffChecker.compare')}</button>
      <button>{t('tools.diffChecker.clear')}</button>
    </div>
  )
}</code></pre>

<h3>Language Switcher Component</h3>

<pre><code>// components/LanguageSwitcher.tsx
'use client'

import { usePathname, useRouter } from 'next/navigation'
import { useIntl } from '@/components/IntlProvider'

export function LanguageSwitcher() {
  const { locale } = useIntl()
  const pathname = usePathname()
  const router = useRouter()

  const switchLocale = (newLocale: string) => {
    // Replace /en/... with /it/...
    const newPath = pathname.replace(`/${locale}`, `/${newLocale}`)

    // Set cookie for persistence
    document.cookie = `NEXT_LOCALE=${newLocale}; path=/; max-age=31536000`

    router.push(newPath)
  }

  return (
    <div>
      <button
        onClick={() => switchLocale('it')}
        className={locale === 'it' ? 'active' : ''}
      >
        ğŸ‡®ğŸ‡¹ IT
      </button>
      <button
        onClick={() => switchLocale('en')}
        className={locale === 'en' ? 'active' : ''}
      >
        ğŸ‡¬ğŸ‡§ EN
      </button>
    </div>
  )
}</code></pre>

<h2>Content Localization</h2>

<h3>Blog Posts with Translation Groups</h3>

<p>Each blog post has a `translationGroup` linking versions in different languages:</p>

<pre><code>// Database schema
interface BlogPost {
  id: string
  slug: string                  // diff-checker-confronta-testi (IT) / diff-checker-compare-texts (EN)
  language: 'it' | 'en'
  translationGroup: string      // 'diff-checker-001' (shared across translations)
  title: string
  content: string
  metaTitle: string
  metaDescription: string
  // ...
}</code></pre>

<pre><code>// app/[locale]/blog/[slug]/page.tsx
export default async function BlogPost({
  params,
}: {
  params: { locale: string; slug: string }
}) {
  const post = await getPostBySlugAndLocale(params.slug, params.locale)

  // Get alternative language version
  const altPost = await getAlternativeTranslation(
    post.translationGroup,
    params.locale === 'it' ? 'en' : 'it'
  )

  return (
    <article>
      {/* hreflang for SEO */}
      <Head>
        <link rel="alternate" hrefLang="en" href={`/en/blog/${post.slug}`} />
        {altPost && (
          <link rel="alternate" hrefLang="it" href={`/it/blog/${altPost.slug}`} />
        )}
      </Head>

      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />

      {/* Link to translation */}
      {altPost && (
        <a href={`/${altPost.language}/blog/${altPost.slug}`}>
          {altPost.language === 'it' ? 'ğŸ‡®ğŸ‡¹ Leggi in Italiano' : 'ğŸ‡¬ğŸ‡§ Read in English'}
        </a>
      )}
    </article>
  )
}</code></pre>

<h3>SEO with hreflang</h3>

<pre><code>// app/[locale]/layout.tsx
export async function generateMetadata({
  params,
}: {
  params: { locale: string }
}) {
  return {
    alternates: {
      canonical: `https://thejord.it/${params.locale}`,
      languages: {
        'it-IT': 'https://thejord.it/it',
        'en-US': 'https://thejord.it/en',
        'x-default': 'https://thejord.it/en',
      },
    },
  }
}</code></pre>

<h2>Local Formatting</h2>

<h3>Dates and Numbers</h3>

<pre><code>// utils/format.ts
export function formatDate(date: Date, locale: string): string {
  return new Intl.DateTimeFormat(locale === 'it' ? 'it-IT' : 'en-US', {
    year: 'numeric',
    month: 'long',
    day: 'numeric',
  }).format(date)
}

export function formatNumber(num: number, locale: string): string {
  return new Intl.NumberFormat(locale === 'it' ? 'it-IT' : 'en-US').format(num)
}

// Usage
formatDate(new Date('2024-12-02'), 'it') // "2 dicembre 2024"
formatDate(new Date('2024-12-02'), 'en') // "December 2, 2024"

formatNumber(1234.56, 'it') // "1.234,56"
formatNumber(1234.56, 'en') // "1,234.56"</code></pre>

<h3>Pluralization</h3>

<pre><code>// utils/pluralize.ts
export function pluralize(
  count: number,
  locale: string,
  options: { one: string; other: string }
): string {
  const pluralRules = new Intl.PluralRules(locale)
  const rule = pluralRules.select(count)

  return options[rule] || options.other
}

// Usage in English
pluralize(1, 'en', { one: '1 file', other: '{{count}} files' })  // "1 file"
pluralize(5, 'en', { one: '1 file', other: '{{count}} files' })  // "5 files"

// Usage in Italian
pluralize(1, 'it', { one: '1 file', other: '{{count}} file' })   // "1 file"
pluralize(5, 'it', { one: '1 file', other: '{{count}} file' })   // "5 file"</code></pre>

<h2>Best Practices Adopted</h2>

<h3>1. Structured Translation Keys</h3>

<pre><code>âœ… GOOD: Hierarchical namespace
{
  "tools": {
    "diffChecker": {
      "title": "Diff Checker",
      "actions": {
        "compare": "Compare",
        "clear": "Clear"
      }
    }
  }
}

âŒ BAD: Flat keys
{
  "diffCheckerTitle": "Diff Checker",
  "diffCheckerCompare": "Compare",
  "diffCheckerClear": "Clear"
}</code></pre>

<h3>2. Avoid Hardcoded Strings</h3>

<pre><code>// âŒ BAD
<button>Compare</button>

// âœ… GOOD
<button>{t('tools.diffChecker.compare')}</button></code></pre>

<h3>3. Message Parameterization</h3>

<pre><code>// Translation
{
  "blog": {
    "publishedOn": "Published on {{date}} by {{author}}"
  }
}

// Usage
t('blog.publishedOn', {
  date: formatDate(post.publishedAt, locale),
  author: post.author
})</code></pre>

<h3>4. RTL Support (Future)</h3>

<pre><code>// Preparation for RTL languages (Arabic, Hebrew)
<html lang={locale} dir={isRTL(locale) ? 'rtl' : 'ltr'}>

function isRTL(locale: string): boolean {
  return ['ar', 'he', 'fa'].includes(locale)
}</code></pre>

<h2>Challenges Faced</h2>

<h3>1. Dynamic Imports for Locale Files</h3>

<p><strong>Problem:</strong> Loading all locale files increases bundle size</p>

<pre><code>// âŒ BAD: Static import
import itTranslations from '@/i18n/locales/it.json'
import enTranslations from '@/i18n/locales/en.json'

// âœ… GOOD: Dynamic import
async function getMessages(locale: string) {
  const messages = await import(`@/i18n/locales/${locale}.json`)
  return messages.default
}</code></pre>

<h3>2. SEO Duplicate Content</h3>

<p><strong>Problem:</strong> Google might penalize similar content in different languages</p>

<p><strong>Solution:</strong> hreflang tags + canonical URLs</p>

<pre><code><link rel="canonical" href="https://thejord.it/en/tools/diff-checker" />
<link rel="alternate" hreflang="it" href="https://thejord.it/it/tools/diff-checker" />
<link rel="alternate" hreflang="en" href="https://thejord.it/en/tools/diff-checker" />
<link rel="alternate" hreflang="x-default" href="https://thejord.it/en/tools/diff-checker" /></code></pre>

<h3>3. Translation Workflow</h3>

<p><strong>Problem:</strong> Keeping translations synchronized during active development</p>

<p><strong>Solution:</strong> Pre-commit validation script</p>

<pre><code>// scripts/validate-translations.ts
import itTranslations from '../i18n/locales/it.json'
import enTranslations from '../i18n/locales/en.json'

function getAllKeys(obj: any, prefix = ''): string[] {
  return Object.entries(obj).flatMap(([key, value]) => {
    const fullKey = prefix ? `${prefix}.${key}` : key
    return typeof value === 'object'
      ? getAllKeys(value, fullKey)
      : [fullKey]
  })
}

const itKeys = new Set(getAllKeys(itTranslations))
const enKeys = new Set(getAllKeys(enTranslations))

const missingInEn = [...itKeys].filter(k => !enKeys.has(k))
const missingInIt = [...enKeys].filter(k => !itKeys.has(k))

if (missingInEn.length > 0) {
  console.error('Missing in EN:', missingInEn)
  process.exit(1)
}

if (missingInIt.length > 0) {
  console.error('Missing in IT:', missingInIt)
  process.exit(1)
}

console.log('âœ… All translations synchronized')</code></pre>

<h2>Metrics and Results</h2>

<h3>Traffic Distribution by Language</h3>

<p>Data from first 30 days post-launch:</p>

<ul>
<li>ğŸ‡®ğŸ‡¹ Italian: 68% of traffic (primary target audience)</li>
<li>ğŸ‡¬ğŸ‡§ English: 32% of traffic (international market)</li>
</ul>

<h3>SEO Performance</h3>

<ul>
<li>Google index: 40 pages (20 IT + 20 EN)</li>
<li>Ranking keywords IT: 15+ in top 10</li>
<li>Ranking keywords EN: 8+ in top 10</li>
<li>Organic CTR: 4.2% (IT), 3.1% (EN)</li>
</ul>

<h2>Next Steps</h2>

<h3>Q2 2025: Language Expansion</h3>

<ul>
<li>ğŸ‡«ğŸ‡· French</li>
<li>ğŸ‡ªğŸ‡¸ Spanish</li>
<li>ğŸ‡©ğŸ‡ª German</li>
</ul>

<h3>Planned Improvements</h3>

<ul>
<li>Automatic translation suggestions with AI (DeepL API)</li>
<li>Translation management dashboard for contributors</li>
<li>A/B testing copy variants for each language</li>
<li>Regional content (e.g., date/time formats specific to US vs UK)</li>
</ul>

<h2>Conclusions</h2>

<p>Internationalizing THEJORD required careful planning but brought evident benefits:</p>

<ul>
<li>âœ… <strong>Global reach</strong>: 32% traffic from non-Italian countries</li>
<li>âœ… <strong>SEO</strong>: 2x keyword rankings vs monolingual</li>
<li>âœ… <strong>User satisfaction</strong>: Positive feedback on localization</li>
<li>âœ… <strong>Scalability</strong>: Architecture ready for new languages</li>
</ul>

<h2>Useful Resources</h2>

<ul>
<li><a href="https://nextjs.org/docs/app/building-your-application/routing/internationalization" target="_blank" rel="noopener">Next.js Internationalization</a></li>
<li><a href="https://formatjs.io/" target="_blank" rel="noopener">FormatJS - i18n library</a></li>
<li><a href="https://developers.google.com/search/docs/specialty/international" target="_blank" rel="noopener">Google International SEO</a></li>
<li><a href="https://github.com/thejord-it/thejord-web" target="_blank" rel="noopener">THEJORD Source Code</a></li>
</ul>

<p><a href="/tools" class="cta-button">Explore THEJORD in English â†’</a></p>
