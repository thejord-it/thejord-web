<h1>Migrazione a Next.js 16: Performance, Turbopack e React 19</h1>

<p>THEJORD.IT è stato costruito con le tecnologie più moderne per garantire performance eccezionali e developer experience ottimale. In questo articolo tecnico raccontiamo il processo di migrazione a <strong>Next.js 16</strong>, le sfide affrontate, i benefici ottenuti e le lezioni apprese.</p>

<h2>Perché Next.js 16</h2>

<p>La decisione di adottare Next.js 16 (con React 19 e Turbopack) è stata guidata da obiettivi chiari:</p>

<ul>
<li><strong>Performance</strong>: Build time ridotto del 70%, hot reload istantaneo</li>
<li><strong>Developer Experience</strong>: Turbopack elimina lentezza di Webpack in dev mode</li>
<li><strong>React 19 Features</strong>: Server Components, Actions, Suspense migliorato</li>
<li><strong>SEO</strong>: Server-Side Rendering (SSR) e Static Site Generation (SSG) built-in</li>
<li><strong>Type Safety</strong>: Integrazione TypeScript nativa first-class</li>
</ul>

<h3>Cosa Cambia rispetto a Next.js 14</h3>

<table>
<thead>
<tr>
<th>Feature</th>
<th>Next.js 14</th>
<th>Next.js 16</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Bundler</strong></td>
<td>Webpack (lento)</td>
<td>Turbopack (10x più veloce)</td>
</tr>
<tr>
<td><strong>React Version</strong></td>
<td>React 18</td>
<td>React 19 (Actions, Suspense++)</td>
</tr>
<tr>
<td><strong>Build Time</strong></td>
<td>~45s (THEJORD)</td>
<td>~12s (THEJORD)</td>
</tr>
<tr>
<td><strong>Hot Reload</strong></td>
<td>1-3s</td>
<td>&lt;200ms</td>
</tr>
<tr>
<td><strong>Server Actions</strong></td>
<td>Experimental</td>
<td>Stable</td>
</tr>
<tr>
<td><strong>Partial Prerendering</strong></td>
<td>❌</td>
<td>✅ (preview)</td>
</tr>
</tbody>
</table>

<h2>Architettura di THEJORD con Next.js 16</h2>

<h3>App Router (app/) vs Pages Router</h3>

<p>THEJORD utilizza la nuova <strong>App Router</strong> introdotta in Next.js 13 e perfezionata in 16:</p>

<pre><code>thejord-web/
├── app/
│   ├── [locale]/              # i18n routing
│   │   ├── layout.tsx         # Root layout (shared)
│   │   ├── page.tsx           # Homepage
│   │   ├── tools/
│   │   │   ├── diff-checker/
│   │   │   │   └── page.tsx   # Diff Checker tool
│   │   │   ├── hash-generator/
│   │   │   │   └── page.tsx   # Hash Generator tool
│   │   │   └── ...
│   │   ├── blog/
│   │   │   ├── page.tsx       # Blog list (SSG)
│   │   │   └── [slug]/
│   │   │       └── page.tsx   # Blog post (SSG)
│   │   └── admin/
│   │       └── posts/
│   │           └── page.tsx   # Admin panel (CSR)
│   └── api/
│       ├── proxy/             # API proxy to backend
│       └── revalidate/        # ISR revalidation
├── components/                # React components
├── lib/                       # Utilities
└── public/                    # Static assets</code></pre>

<h3>Rendering Strategies</h3>

<p>THEJORD combina diverse strategie per ottimizzare performance e SEO:</p>

<h4>1. Static Site Generation (SSG) - Blog Posts</h4>

<pre><code>// app/[locale]/blog/[slug]/page.tsx
export async function generateStaticParams() {
  const posts = await getPosts()
  return posts.map((post) => ({
    slug: post.slug,
  }))
}

export default async function BlogPost({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug)

  return (
    <article>
      <h1>{post.title}</h1>
      <div dangerouslySetInnerHTML={{ __html: post.content }} />
    </article>
  )
}

// Metadata SEO generata a build time
export async function generateMetadata({ params }: { params: { slug: string } }) {
  const post = await getPost(params.slug)
  return {
    title: post.metaTitle,
    description: post.metaDescription,
  }
}</code></pre>

<p><strong>Benefici:</strong> HTML pre-renderizzato, instant loading, perfect SEO</p>

<h4>2. Incremental Static Regeneration (ISR) - Tool Pages</h4>

<pre><code>// app/[locale]/tools/diff-checker/page.tsx
export const revalidate = 3600 // Revalidate ogni ora

export default function DiffChecker() {
  return <DiffCheckerComponent />
}

// API per forzare revalidation
// POST /api/revalidate?path=/tools/diff-checker
export async function POST(request: Request) {
  const { path } = await request.json()
  await revalidate(path)
  return Response.json({ revalidated: true })
}</code></pre>

<p><strong>Benefici:</strong> Static speed + dynamic freshness</p>

<h4>3. Client-Side Rendering (CSR) - Admin Panel</h4>

<pre><code>// app/[locale]/admin/posts/page.tsx
'use client'

import { useState, useEffect } from 'react'

export default function AdminPosts() {
  const [posts, setPosts] = useState([])

  useEffect(() => {
    fetch('/api/proxy/api/posts')
      .then(res => res.json())
      .then(setPosts)
  }, [])

  return <PostsTable posts={posts} />
}</code></pre>

<p><strong>Benefici:</strong> Interattività, real-time updates, protected routes</p>

<h2>Turbopack: Il Nuovo Bundler</h2>

<h3>Webpack vs Turbopack: Benchmark Reali</h3>

<p>Test eseguiti su THEJORD codebase (45 componenti, 120 file):</p>

<table>
<thead>
<tr>
<th>Operazione</th>
<th>Webpack (Next 14)</th>
<th>Turbopack (Next 16)</th>
<th>Miglioramento</th>
</tr>
</thead>
<tbody>
<tr>
<td>Cold start</td>
<td>8.2s</td>
<td>1.1s</td>
<td>7.5x più veloce</td>
</tr>
<tr>
<td>Hot reload (small change)</td>
<td>2.1s</td>
<td>0.15s</td>
<td>14x più veloce</td>
</tr>
<tr>
<td>Production build</td>
<td>44s</td>
<td>12s</td>
<td>3.7x più veloce</td>
</tr>
<tr>
<td>Memory usage (dev)</td>
<td>850MB</td>
<td>420MB</td>
<td>-50%</td>
</tr>
</tbody>
</table>

<h3>Come Abilitare Turbopack</h3>

<pre><code>// next.config.mjs
const nextConfig = {
  // Dev mode con Turbopack
  experimental: {
    turbo: {
      rules: {
        '*.svg': {
          loaders: ['@svgr/webpack'],
          as: '*.js',
        },
      },
    },
  },
}

export default nextConfig</code></pre>

<pre><code># package.json
{
  "scripts": {
    "dev": "next dev --turbo",
    "build": "next build",
    "start": "next start"
  }
}</code></pre>

<h3>Gotchas e Limitazioni</h3>

<ul>
<li><strong>Custom Webpack config</strong>: Non completamente supportata, richiede migration</li>
<li><strong>Some loaders</strong>: Potrebbero non funzionare (es. vecchi Webpack loaders)</li>
<li><strong>Source maps</strong>: Formato leggermente diverso, alcuni debugger potrebbero avere issue</li>
</ul>

<h2>React 19 Server Components</h2>

<h3>Quando Usare Server Components</h3>

<p>Server Components eseguono sul server, riducono JavaScript inviato al client:</p>

<pre><code>// components/BlogPostList.tsx (Server Component)
async function BlogPostList() {
  // Fetch diretto da database, senza API call client-side
  const posts = await db.posts.findMany({
    where: { published: true },
    orderBy: { publishedAt: 'desc' }
  })

  return (
    <div>
      {posts.map(post => (
        <BlogCard key={post.id} post={post} />
      ))}
    </div>
  )
}

// Nessun 'use client' → Server Component di default</code></pre>

<p><strong>Benefici:</strong></p>
<ul>
<li>Zero JavaScript client-side per rendering</li>
<li>Accesso diretto a database/filesystem</li>
<li>Nessun waterfall di API calls</li>
<li>Bundle size ridotto</li>
</ul>

<h3>Quando Usare Client Components</h3>

<pre><code>// components/DiffChecker.tsx (Client Component)
'use client'

import { useState } from 'react'
import { diffLines } from 'diff'

export function DiffChecker() {
  const [text1, setText1] = useState('')
  const [text2, setText2] = useState('')
  const [diff, setDiff] = useState([])

  const handleCompare = () => {
    const result = diffLines(text1, text2)
    setDiff(result)
  }

  return (
    // UI interattiva con state, events, browser APIs
  )
}</code></pre>

<p><strong>Usa Client Components per:</strong></p>
<ul>
<li>State (useState, useReducer)</li>
<li>Effects (useEffect, custom hooks)</li>
<li>Event handlers (onClick, onChange)</li>
<li>Browser APIs (localStorage, Web Workers)</li>
<li>Third-party interactive libraries</li>
</ul>

<h3>Composition Pattern</h3>

<pre><code>// app/[locale]/tools/diff-checker/page.tsx (Server Component)
import { DiffChecker } from '@/components/DiffChecker'
import { ToolMetadata } from '@/components/ToolMetadata'

export default async function DiffCheckerPage() {
  // Fetch metadata sul server
  const metadata = await getToolMetadata('diff-checker')

  return (
    <div>
      {/* Server Component */}
      <ToolMetadata metadata={metadata} />

      {/* Client Component passato come children */}
      <DiffChecker />
    </div>
  )
}</code></pre>

<h2>React 19 Server Actions</h2>

<p>Server Actions permettono di chiamare funzioni server da client senza creare API route:</p>

<pre><code>// app/actions.ts
'use server'

import { db } from '@/lib/db'
import { revalidatePath } from 'next/cache'

export async function createPost(formData: FormData) {
  const title = formData.get('title') as string
  const content = formData.get('content') as string

  const post = await db.posts.create({
    data: { title, content, published: false }
  })

  revalidatePath('/admin/posts')
  return { success: true, postId: post.id }
}

export async function publishPost(postId: string) {
  await db.posts.update({
    where: { id: postId },
    data: { published: true, publishedAt: new Date() }
  })

  revalidatePath('/blog')
  return { success: true }
}</code></pre>

<pre><code>// components/CreatePostForm.tsx
'use client'

import { createPost } from '@/app/actions'
import { useFormStatus } from 'react-dom'

function SubmitButton() {
  const { pending } = useFormStatus()
  return (
    <button type="submit" disabled={pending}>
      {pending ? 'Creating...' : 'Create Post'}
    </button>
  )
}

export function CreatePostForm() {
  return (
    <form action={createPost}>
      <input name="title" required />
      <textarea name="content" required />
      <SubmitButton />
    </form>
  )
}</code></pre>

<p><strong>Benefici:</strong></p>
<ul>
<li>No API route boilerplate</li>
<li>Type-safe client-server communication</li>
<li>Progressive enhancement (funziona senza JS)</li>
<li>Automatic revalidation</li>
</ul>

<h2>Migrazione Step-by-Step</h2>

<h3>1. Preparazione</h3>

<pre><code># Backup codebase
git checkout -b migration-nextjs-16

# Update dependencies
npm install next@latest react@latest react-dom@latest
npm install --save-dev @types/react@latest @types/react-dom@latest</code></pre>

<h3>2. Migrare a App Router</h3>

<pre><code># Struttura vecchia (pages/)
pages/
├── index.tsx
├── tools/
│   └── diff-checker.tsx
└── blog/
    └── [slug].tsx

# Nuova struttura (app/)
app/
├── page.tsx                  # pages/index.tsx
├── tools/
│   └── diff-checker/
│       └── page.tsx          # pages/tools/diff-checker.tsx
└── blog/
    └── [slug]/
        └── page.tsx          # pages/blog/[slug].tsx</code></pre>

<h3>3. Convertire getStaticProps → Server Components</h3>

<pre><code>// ❌ Vecchio (pages/)
export async function getStaticProps() {
  const posts = await getPosts()
  return { props: { posts } }
}

export default function Blog({ posts }) {
  return <PostsList posts={posts} />
}

// ✅ Nuovo (app/)
export default async function Blog() {
  const posts = await getPosts() // Fetch diretto
  return <PostsList posts={posts} />
}</code></pre>

<h3>4. Migrare API Routes</h3>

<pre><code>// pages/api/posts.ts → app/api/posts/route.ts

// ❌ Vecchio
export default async function handler(req, res) {
  if (req.method === 'GET') {
    const posts = await getPosts()
    res.json(posts)
  }
}

// ✅ Nuovo
export async function GET() {
  const posts = await getPosts()
  return Response.json(posts)
}

export async function POST(request: Request) {
  const body = await request.json()
  const post = await createPost(body)
  return Response.json(post, { status: 201 })
}</code></pre>

<h3>5. Update next.config.js</h3>

<pre><code>// next.config.mjs
const nextConfig = {
  // Abilita Turbopack in dev
  experimental: {
    turbo: {},
  },

  // i18n routing
  i18n: {
    locales: ['it', 'en'],
    defaultLocale: 'it',
  },

  // Image optimization
  images: {
    domains: ['thejord.it'],
  },
}

export default nextConfig</code></pre>

<h2>Performance Improvements Ottenuti</h2>

<h3>Lighthouse Scores (Before/After)</h3>

<table>
<thead>
<tr>
<th>Metric</th>
<th>Next.js 14</th>
<th>Next.js 16</th>
<th>Δ</th>
</tr>
</thead>
<tbody>
<tr>
<td>Performance</td>
<td>87</td>
<td>98</td>
<td>+11</td>
</tr>
<tr>
<td>First Contentful Paint</td>
<td>1.2s</td>
<td>0.7s</td>
<td>-42%</td>
</tr>
<tr>
<td>Time to Interactive</td>
<td>2.8s</td>
<td>1.1s</td>
<td>-61%</td>
</tr>
<tr>
<td>Total Bundle Size</td>
<td>185KB</td>
<td>92KB</td>
<td>-50%</td>
</tr>
<tr>
<td>SEO Score</td>
<td>95</td>
<td>100</td>
<td>+5</td>
</tr>
</tbody>
</table>

<h3>Real User Metrics (RUM)</h3>

<p>Dati da Google Analytics dopo 30 giorni dal lancio:</p>

<ul>
<li>Average page load: 0.9s (era 2.1s)</li>
<li>Bounce rate: 12% (era 28%)</li>
<li>Pages per session: 3.2 (era 1.8)</li>
<li>Session duration: 4:23 min (era 2:11 min)</li>
</ul>

<h2>Sfide e Lezioni Apprese</h2>

<h3>1. Hydration Mismatch Errors</h3>

<p><strong>Problema:</strong> Server Component rende HTML diverso da Client Component</p>

<pre><code>// ❌ Causa hydration mismatch
export default function Time() {
  return <div>{new Date().toLocaleString()}</div>
}

// ✅ Soluzione: use effect o suppressHydrationWarning
'use client'
export default function Time() {
  const [time, setTime] = useState('')

  useEffect(() => {
    setTime(new Date().toLocaleString())
  }, [])

  return <div>{time || 'Loading...'}</div>
}</code></pre>

<h3>2. Third-party Libraries non Compatibili</h3>

<p><strong>Problema:</strong> Alcune librerie non funzionano con Server Components</p>

<pre><code>// ❌ Error: 'window' is not defined
import SomeLibrary from 'some-library'

// ✅ Soluzione: dynamic import con ssr: false
'use client'
import dynamic from 'next/dynamic'

const SomeLibrary = dynamic(() => import('some-library'), {
  ssr: false
})</code></pre>

<h3>3. Caching Aggressivo</h3>

<p><strong>Problema:</strong> Next.js 16 cache aggressivo di fetch requests</p>

<pre><code>// ❌ Cache indefinito
const data = await fetch('https://api.example.com/data')

// ✅ Disabilita cache esplicito
const data = await fetch('https://api.example.com/data', {
  cache: 'no-store'
})

// ✅ Revalidate ogni 60 secondi
const data = await fetch('https://api.example.com/data', {
  next: { revalidate: 60 }
})</code></pre>

<h2>Best Practices per Next.js 16</h2>

<ul>
<li><strong>Default to Server Components</strong>: Usa 'use client' solo quando necessario</li>
<li><strong>Colocate Server/Client</strong>: Componi Server e Client Components strategicamente</li>
<li><strong>Minimize Client JS</strong>: Sposta logica non interattiva sul server</li>
<li><strong>Use Suspense</strong>: Wrap async components in Suspense per loading states</li>
<li><strong>Optimize Images</strong>: Usa next/image per automatic optimization</li>
<li><strong>Configure Caching</strong>: Sii esplicito con fetch caching strategy</li>
</ul>

<h2>Conclusioni</h2>

<p>La migrazione a Next.js 16 ha portato miglioramenti significativi a THEJORD:</p>

<ul>
<li>✅ <strong>Performance</strong>: 3x più veloce in build, 7x in dev</li>
<li>✅ <strong>User Experience</strong>: Load time dimezzato, bundle size -50%</li>
<li>✅ <strong>SEO</strong>: Lighthouse 100/100, perfect metadata</li>
<li>✅ <strong>Developer Experience</strong>: Hot reload istantaneo, meno boilerplate</li>
</ul>

<p><strong>Consiglieresti Next.js 16?</strong> Assolutamente sì per progetti nuovi. Per migration, valuta complexity del codebase: App Router richiede refactoring significativo.</p>

<h2>Risorse Utili</h2>

<ul>
<li><a href="https://nextjs.org/docs" target="_blank" rel="noopener">Next.js 16 Documentation</a></li>
<li><a href="https://react.dev/blog/2024/12/05/react-19" target="_blank" rel="noopener">React 19 Release Notes</a></li>
<li><a href="https://turbo.build/pack/docs" target="_blank" rel="noopener">Turbopack Documentation</a></li>
<li><a href="https://github.com/thejord-it/thejord-web" target="_blank" rel="noopener">THEJORD Source Code (GitHub)</a></li>
</ul>

<p><a href="/tools" class="cta-button">Prova THEJORD con Next.js 16 →</a></p>
